---
title: Java编程：结构化与面向对象的对决
keywords:
  - 编程
  - 面向对象
  - Java
  - 方法
  - 重载
  - 构造器
categories:
  - 新时代码农
tags:
  - 编程
  - 面向对象
  - Java
  - 方法
  - 重载
  - 构造器
abbrlink: c8b315d3
date: 2012-05-18 00:00:00
ai:
  - 本文深入探讨了结构化编程和面向对象编程的区别。文章详细介绍了如何编写Java类，实例化对象，访问对象的属性和方法，以及理解this引用的概念。此外，还涵盖了包的用法、封装、继承、多态等面向对象的特点，并解释了基本数据类型和引用类型的传递特性。最后，文章阐述了对象的生命周期管理，包括对象的销毁和垃圾回收机制，以及JavaBean规范和对象之间的关系。同时，对方法调用栈、方法重载和构造器进行了详细的解析。
description: 本文深入探讨了结构化编程和面向对象编程的区别。文章详细介绍了如何编写Java类，实例化对象，访问对象的属性和方法，以及理解this引用的概念。此外，还涵盖了包的用法、封装、继承、多态等面向对象的特点，并解释了基本数据类型和引用类型的传递特性。最后，文章阐述了对象的生命周期管理，包括对象的销毁和垃圾回收机制，以及JavaBean规范和对象之间的关系。同时，对方法调用栈、方法重载和构造器进行了详细的解析。
---

- 理解结构化编程和面向对象编程的区别
- 掌握如何编写 java 类
- 掌握如何实例化对象
- 掌握如何访问对象的属性和方法
- 理解 this 引用
- 掌握如何使用包组织类

##### 结构化编程

按照步骤来编写代码  
围绕要解决的任务来设计

##### 面向对象编程 (Object Oriented Programming)

程序不是围绕要解决任务来设计, 而是围绕要解决的问题中的对象来设计  
建立对象模型, 将问题域化为不同的对象去处理

**万物皆对象, 对象因关注而产生**

对象组成

1. 属性

- 对象身上的值数据

2. 行为

- 该对象能够做什么

类是对象的抽象, 对象是类的实例  
类是具有相同属性和行为的一组对象的抽象

#### 面向对象特点

1. 封装
2. 继承
3. 多态
4. 方法重载
5. 方法覆盖

**基本数据类型和引用类型的传递的特点**

- 值传递：(形式参数类型是基本数据类型)：方法调用时，实际参数把它的值传递给对应的形式参数，形式参数只是用实际参数的值初始化自己的存储单元内容，是两个不同的存储单元，所以方法执行中形式参数值的改变不影响实际参数的值。
- 引用传递：(形式参数类型是引用数据类型参数)：也称为传地址。方法调用时，实际参数是对象 (或数组)，这时实际参数与形式参数指向同一个地址，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，这个结果在方法结束后被保留了下来，所以方法执行中形式参数的改变将会影响实际参数

**对象的销毁**

- 产生了对象, 用完之后, 自然要关心它的销毁
- 如果一个对象没有任何引用, 那么就具备了被垃圾回收机制回收的条件
- 如果我们想主动通知垃圾回收机制一个对象, 只需要 –> 对象 = null;

只用一次的对象, 可以用匿名对象, 就是没有引用指向这个对象的对象

**访问修饰符**  
public: 谁都可以操控  
private: 除了自己, 谁都不能操作  
默认: 同一个包内可以操作  
protected: 同包或者之内可以操作

**this:**

1. 对当前类的引用;
2. 每个对象都有一个隐含的 this 变量, 它可以访问类的所有信息;
3. 构造方法的相互调用, 必须放在构造方法内的第一个语句;

this 关键字的第二种用法  
在重载的构造器中, 为了重复利用代码

```java
class Gril {
    private int age;
    private String name;
    //构造方法
    public Gril(int age ,String name){
        this(name);
        this.age = age;
        //this.name = name;
    }
    public Gril(String name){
        this.name = name;
    }
    public Gril(){

    }
    //睡觉的方法
    public void sleep(Car car){
        System.out.println("在车上睡觉");
    }
    public void sleep(Bed bed){
        System.out.println("在床上睡觉");
    }
    public void sleep(){
        System.out.println("在野外睡觉");
    }
}
```

**JavaBean 规范:**  
为私有属性提供符合命名规范的 set 和 get 方法

1. JavaBean 必须方法一个包中
2. JavaBean 必须声明为 public class
3. JavaBean 的所有属性必须声明为 private
4. 通过 setter 和 getter 方法设值和取值
5. 通过 JSP 调用是, 则需要一个无参的构造方法
6. 编写代码要严格遵循 Java 程序的命名规范

**对象和对象的关系**

1. **has a**(拥有一个):  
   如果 a 对象和 b 对象是这种关系, 则把 b 作为 a 的属性
2. **use a**(使用一个):  
   如果 a 只是使用一下 b 对象, 则作为局部变量  
   2 种方法: new 一个新对象; 通过参数传递

### 目标

1. 掌握方法的申明与调用
2. 理解方法调用栈
3. 理解方法重载
4. 理解构造器

### 1. 方法调用栈 (stack)

- 选择语句
- 循环语句
- 方法的调用 (先进后出)
  - 当一个方法正在执行时的三种情况
    - 方法返回一个值, 在这种情况下, 一个基本数据类型或引用类型被传回给方法的调用者
    - 方法不返回, 返回值被声明为 void
    - 方法抛出一个异常给方法的调用者

### 2. 方法的生命和调用

#### 方法签名

- 方法的签名包括方法名, 参数列表, 返回值的数据类型  
   `public static void main(String[] args)`

  - 访问修饰符
  - 可选修饰符
  - 返回类型
  - 方法名
  - 形参列表
    - 个数, 顺序, 类型
  - 抛出的
  - 异常列表

### 3. 方法重载

同一个类中的方法名相同, 参数列表不同; 和返回值类型无关  
**为什么不能用返回值类型类区分重载**  
比如下面两个方法，虽然他们有同样的名字和形式，但却很容易区分它们：  
Java 代码 `void f(){}` `int f(){reurn1;}`  
只要编译器可以根据语境明确判断出语义，比如在 int x =f() 中，那么的确可以据此区分重载方法。  
不过，有时你并不关心方法的返回值，你想要的是方法调用的其他效果，这时你可能会调用方法而忽略其返回值。  
所以，如果像下面这样调用方法：f()；此时 Java 如何才能判断该调用哪一个 f() 呢？  
因此，根据方法的返回值来区分重载方法是行不通的

### 4. 构造器

`访问修饰符 类名(){}`

1. 没有返回类型
2. 方法名和类名一样
3. 如果不写, 系统会默认提供一个构造方法
4. 如果写了, 系统就不会提供任何构造方法

**作用:** 产生对象  
new 一个对象的时候构造器所要做的事

1. 创建空间
2. 划分属性
3. 初始化值
4. 执行构造方法内的语句
